// g2panel_libgpiodv2.c
// --------------------
// NOTE (2026-01):
//   * This file is selected automatically by the P2_app Makefile when libgpiod major version is 2+.
//   * It exists under this clearer name to avoid confusion with g2v2panel.c.
//   * Historically, early Trixie testing used a helper script to emit a v2-compatible panel file.
//     The repo now tracks this file directly; scripts should not overwrite source files at build time.
//
// IMPORTANT: Do not remove comments from the original implementation.

// /////////////////////////////////////////////////////////////
// Saturn project: Artix7 FPGA + Raspberry Pi4 Compute Module
// g2panel_v2.c â€” libgpiod v2-compatible implementation
// Based on original g2panel.c; only the GPIO access layer is ported.
//
// This file is generated by patch-trixie-gpiod.sh
// /////////////////////////////////////////////////////////////

#include "g2panel.h"
#include "threaddata.h"
#include <stdint.h>
#include "../common/saturntypes.h"
#include <errno.h>
#include <time.h>
#include <stdlib.h>
#include <stddef.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>
#include <fcntl.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <gpiod.h>
#include <sys/syscall.h>

#include <linux/i2c-dev.h>
#include "../common/saturnregisters.h"
#include "../common/saturndrivers.h"
#include "../common/hwaccess.h"
#include "../common/debugaids.h"
#include "cathandler.h"
#include "i2cdriver.h"
#include "cathandler.h"
#include "andromedacatmessages.h"

#define HWVERSION 2
#define PRODUCTID 4

int i2c_fd;
char* pi_i2c_device = (char*)"/dev/i2c-1";
unsigned int G2MCP23017 = 0x20;
unsigned int G2V2Arduino = 0x15;

bool G2PanelControlled = false;
static struct gpiod_chip *chip = NULL;
char* gpio_device = NULL;
char *consumer = (char*)"p2app";

/* v2 GPIO handles */
static struct gpiod_line_request *VFORequest = NULL;              // request for offsets 17 (edge) and 18 (input)
static struct gpiod_edge_event_buffer *VFOEdgeBuf = NULL;
static struct gpiod_line_request *PBRequest = NULL;               // bulk inputs for encoders/pushbuttons

pthread_t VFOEncoderThread;
pthread_t G2PanelTickThread;
uint16_t GDeltaCount;
bool G2PanelActive = false;
bool EncodersInitialised = false;
bool CATDetected = false;

#define VNUMGPIOPUSHBUTTONS 4
#define VNUMMCPPUSHBUTTONS 16
#define VNUMBUTTONS (VNUMGPIOPUSHBUTTONS+VNUMMCPPUSHBUTTONS)
#define VNUMENCODERS 8
#define VNUMGPIO (2*VNUMENCODERS + VNUMGPIOPUSHBUTTONS)

uint32_t PBIOPins[VNUMGPIO] = {20, 26, 6, 5, 4, 21, 7, 9,
                               16, 19, 10, 11, 25, 8, 12, 13,
                               22, 27, 23, 24};
int32_t IOPinValues[VNUMGPIO] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

uint8_t PBPinShifts [VNUMBUTTONS] =
  {0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF};

uint8_t PBLongCount [VNUMBUTTONS] =
  {0x0, 0x0, 0x0, 0x0,
   0x0, 0x0, 0x0, 0x0,
   0x0, 0x0, 0x0, 0x0,
   0x0, 0x0, 0x0, 0x0,
   0x0, 0x0, 0x0, 0x0};

uint8_t EncoderStates[VNUMENCODERS];
int8_t  EncoderCounts[VNUMENCODERS];
#define VLONGPRESSCOUNT 100
#define VKEEPALIVECOUNT 1500

uint8_t LookupEncoderCode [] = {11, 12, 1, 2, 5, 6, 9, 10};
uint8_t LookupButtonCode []  = {47, 50, 45, 44, 31, 32, 30, 34, 35, 33, 36, 37, 38, 21, 42, 43, 11, 1, 5, 9};

bool CheckG2PanelPresent(void)
{
    bool Result = false;
    bool Error;
    i2c_fd=open(pi_i2c_device, O_RDWR);
    if(i2c_fd < 0) {
        printf("failed to open i2c device\n");
    } else if(ioctl(i2c_fd, I2C_SLAVE, G2MCP23017) >= 0) {
        i2c_read_byte_data(0x0, &Error);
        if (!Error)
            Result = true;
        else
            close(i2c_fd);
    }
    return Result;
}

#define VOPTENCODERDIVISOR 1

int8_t ReadOpticalEncoder(void)
{
  int8_t Result;
  Result = GDeltaCount / VOPTENCODERDIVISOR;
  GDeltaCount = GDeltaCount % VOPTENCODERDIVISOR;
  return Result;
}

void* VFOEventHandler(__attribute__((unused)) void *arg)
{
    int returnval;
    const int64_t timeout_ns = 1000000000LL; /* 1 second */
    uint8_t DirectionBit;

    printf("Started VFO event handler thread, pid=%ld\n", syscall(SYS_gettid));
    while(G2PanelActive)
    {
        returnval = gpiod_line_request_wait_edge_events(VFORequest, timeout_ns);
        if(returnval > 0)
        {
            int n = gpiod_line_request_read_edge_events(VFORequest, VFOEdgeBuf, 16);
            for (int i = 0; i < n; i++) {
                struct gpiod_edge_event *ev = gpiod_edge_event_buffer_get_event(VFOEdgeBuf, i);
                if (!ev) continue;
                if (gpiod_edge_event_get_line_offset(ev) == 17 &&
                    gpiod_edge_event_get_event_type(ev) == GPIOD_EDGE_EVENT_RISING_EDGE) {
                    enum gpiod_line_value val = gpiod_line_request_get_value(VFORequest, 18);
                    DirectionBit = (val == GPIOD_LINE_VALUE_ACTIVE) ? 1 : 0;
                    if(DirectionBit) GDeltaCount--; else GDeltaCount++;
                }
                /* Do NOT free the event here; its lifetime is owned by VFOEdgeBuf in libgpiod v2 */
            }
        }
    }
    return NULL;
}

int8_t EncoderStepTable[] = {0,1,-1,2,
                             -1,0,2, 1,
                             1,2,0,-1,
                             2,-1,1,0};

void EncoderTick(uint32_t Enc, uint8_t Pin1, uint8_t Pin2)
{
    EncoderStates[Enc] = ((EncoderStates[Enc] << 2) | (Pin2 << 1) | Pin1) & 0x0F;
    if(EncodersInitialised)
        EncoderCounts[Enc] += EncoderStepTable[EncoderStates[Enc]];
}

uint32_t TickCounter;
#define VFASTTICKSPERSLOWTICK 3

int8_t GetEncoderCount(uint8_t Enc)
{
    int8_t Result;
    Result = EncoderCounts[Enc]/2;
    EncoderCounts[Enc] = EncoderCounts[Enc]%2;
    return Result;
}

void* G2PanelTick(__attribute__((unused)) void *arg)
{
    int8_t Steps;
    uint8_t ScanCode;
    uint8_t PinCntr;
    uint32_t MCPData;
    uint32_t Cntr;
    bool I2Cerror;

    printf("Started G2 panel tick thread, pid=%ld\n", syscall(SYS_gettid));
    while(G2PanelActive)
    {
        if(CATPortAssigned)
        {
            if(CATDetected == false)
            {
                CATDetected = true;
                MakeProductVersionCAT(PRODUCTID, HWVERSION, GetP2appVersion());
            }
        }
        else
            CATDetected = false;

        TickCounter++;

        /* Bulk read inputs via v2 request */
        {
            enum gpiod_line_value vals[VNUMGPIO];
            if (gpiod_line_request_get_values(PBRequest, vals) == 0) {
                for (uint32_t k = 0; k < VNUMGPIO; k++)
                    IOPinValues[k] = (vals[k] == GPIOD_LINE_VALUE_ACTIVE) ? 1 : 0;
            }
        }

        /* Process encoders */
        for(Cntr=0; Cntr < VNUMENCODERS; Cntr++)
            EncoderTick(Cntr, IOPinValues[2*Cntr], IOPinValues[2*Cntr+1]);
        EncodersInitialised = true;

        /* Slower tick */
        if(TickCounter >= VFASTTICKSPERSLOWTICK)
        {
            TickCounter=0;

            /* Read MCP and pushbuttons */
            MCPData = i2c_read_word_data(0x12, &I2Cerror);
            for (Cntr = 16; Cntr < 20; Cntr++)
                MCPData |= (IOPinValues[Cntr] << Cntr);

            for(PinCntr=0; PinCntr < VNUMBUTTONS; PinCntr++)
            {
                PBPinShifts[PinCntr] = ((PBPinShifts[PinCntr] << 1) | (MCPData & 1)) & 0b00000111;
                MCPData = MCPData >> 1;
                ScanCode = LookupButtonCode[PinCntr];
                if(PBPinShifts[PinCntr] == 0b00000100) {
                    MakePushbuttonCAT(ScanCode, 1);
                    PBLongCount[PinCntr] = VLONGPRESSCOUNT;
                }
                else if (PBPinShifts[PinCntr] == 0b00000011) {
                    MakePushbuttonCAT(ScanCode, 0);
                    PBLongCount[PinCntr] = 0;
                }
                else if(PBLongCount[PinCntr] != 0) {
                    if(--PBLongCount[PinCntr] == 0) {
                        MakePushbuttonCAT(ScanCode, 2);
                    }
                }
            }

            /* Mechanical encoders */
            for(Cntr=0; Cntr < VNUMENCODERS; Cntr++)
            {
                ScanCode = LookupEncoderCode[Cntr];
                Steps = GetEncoderCount(Cntr);
                MakeEncoderCAT(Steps, ScanCode);
            }

            /* Optical encoder */
            Steps = ReadOpticalEncoder();
            MakeVFOEncoderCAT(Steps);
        }

        usleep(3333); /* ~3.3ms */
    }
    return NULL;
}

void SetupG2PanelGPIO(void)
{
    chip = NULL;

    if (chip == NULL) {
        gpio_device = (char*)"/dev/gpiochip4"; /* RPi5 */
        chip = gpiod_chip_open(gpio_device);
    }
    if (chip == NULL) {
        gpio_device = (char*)"/dev/gpiochip0"; /* RPi4 */
        chip = gpiod_chip_open(gpio_device);
    }
    if (chip == NULL) {
        printf("%s: open chip failed\n", __FUNCTION__);
        return;
    }

    printf("%s: G2 panel GPIO device=%s\n", __FUNCTION__, gpio_device);

    /* VFO lines: 17 with rising-edge events, 18 as input */
    {
        unsigned int vfo_offsets[2] = {17, 18};
        struct gpiod_line_settings *ls_edge = gpiod_line_settings_new();
        struct gpiod_line_settings *ls_in   = gpiod_line_settings_new();
        struct gpiod_line_config   *lc      = gpiod_line_config_new();
        struct gpiod_request_config *rc     = gpiod_request_config_new();

        gpiod_line_settings_set_direction(ls_edge, GPIOD_LINE_DIRECTION_INPUT);
        gpiod_line_settings_set_edge_detection(ls_edge, GPIOD_LINE_EDGE_RISING);
        gpiod_line_settings_set_direction(ls_in, GPIOD_LINE_DIRECTION_INPUT);

        gpiod_line_config_add_line_settings(lc, &vfo_offsets[0], 1, ls_edge);
        gpiod_line_config_add_line_settings(lc, &vfo_offsets[1], 1, ls_in);
        gpiod_request_config_set_consumer(rc, consumer);

        VFORequest = gpiod_chip_request_lines(chip, rc, lc);

        gpiod_request_config_free(rc);
        gpiod_line_config_free(lc);
        gpiod_line_settings_free(ls_edge);
        gpiod_line_settings_free(ls_in);

        if (!VFORequest) {
            printf("Failed to request VFO lines\n");
            return;
        }
        VFOEdgeBuf = gpiod_edge_event_buffer_new(16);
    }

    /* Bulk inputs for encoders/pushbuttons */
    {
        struct gpiod_line_settings *ls_in   = gpiod_line_settings_new();
        struct gpiod_line_config   *lc      = gpiod_line_config_new();
        struct gpiod_request_config *rc     = gpiod_request_config_new();

        gpiod_line_settings_set_direction(ls_in, GPIOD_LINE_DIRECTION_INPUT);
        gpiod_line_config_add_line_settings(lc, PBIOPins, VNUMGPIO, ls_in);
        gpiod_request_config_set_consumer(rc, consumer);

        PBRequest = gpiod_chip_request_lines(chip, rc, lc);

        gpiod_request_config_free(rc);
        gpiod_line_config_free(lc);
        gpiod_line_settings_free(ls_in);

        if (!PBRequest) {
            printf("Failed to request PB/encoder input lines\n");
        }
    }
}

void SetupG2PanelI2C(void)
{
  if (i2c_write_byte_data(0x0A, 0x00) < 0) { return; }
  if (i2c_write_byte_data(0x0B, 0x00) < 0) { return; }
  if (i2c_write_byte_data(0x04, 0x00) < 0) { return; }
  if (i2c_write_byte_data(0x05, 0x00) < 0) { return; }
  if (i2c_write_byte_data(0x06, 0x00) < 0) { return; }
  if (i2c_write_byte_data(0x07, 0x00) < 0) { return; }
  if (i2c_write_byte_data(0x14, 0x00) < 0) { return; }
  if (i2c_write_byte_data(0x15, 0x00) < 0) { return; }
  if (i2c_write_byte_data(0x0C, 0xFF) < 0) { return; }
  if (i2c_write_byte_data(0x0D, 0xFF) < 0) { return; }
  if (i2c_write_byte_data(0x02, 0x00) < 0) { return; }
  if (i2c_write_byte_data(0x03, 0x00) < 0) { return; }
  if (i2c_write_byte_data(0x00, 0xFF) < 0) { return; }
  if (i2c_write_byte_data(0x01, 0xFF) < 0) { return; }
  if (i2c_write_byte_data(0x08, 0x00) < 0) { return; }
  if (i2c_write_byte_data(0x09, 0x00) < 0) { return; }
}

void InitialiseG2PanelHandler(void)
{
    G2PanelControlled = true;
    SetupG2PanelGPIO();
    SetupG2PanelI2C();

    G2PanelActive = true;
    if(pthread_create(&VFOEncoderThread, NULL, VFOEventHandler, NULL) < 0)
        perror("pthread_create VFO encoder");
    pthread_detach(VFOEncoderThread);

    if(pthread_create(&G2PanelTickThread, NULL, G2PanelTick, NULL) < 0)
        perror("pthread_create G2 panel tick");
    pthread_detach(G2PanelTickThread);
}

void ShutdownG2PanelHandler(void)
{
    if (chip != NULL)
    {
        G2PanelActive = false;
        sleep(2);
        if (VFORequest) {
            if (VFOEdgeBuf) { gpiod_edge_event_buffer_free(VFOEdgeBuf); VFOEdgeBuf = NULL; }
            gpiod_line_request_release(VFORequest);
            VFORequest = NULL;
        }
        if (PBRequest) {
            gpiod_line_request_release(PBRequest);
            PBRequest = NULL;
        }
        gpiod_chip_close(chip);
    }
    close(i2c_fd);
}
